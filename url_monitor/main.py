#!/usr/bin/python
# -*- coding: utf-8 -*-
from __future__ import print_function

import argparse
import json
import logging
import os
import sys
import textwrap
import requests
from exception import PidlockConflict

import action
import commons
import configuration
from exception import PidlockConflict

import zbxsend as event
from zbxsend import Metric

from url_monitor import authors as authorsmacro
from url_monitor import description as descriptionmacro
from url_monitor import authors as emailsmacro
from url_monitor import project as projectmacro

__doc__ = """Program entry point / arg handling / check passfail review"""


def return_epilog():
    """ Formats the eplig footer generated by help """
    author_strings = []
    for name, email in zip(authorsmacro, emailsmacro):
        author_strings.append('Author: {0} <{1}>'.format(name, email))
    return (
        "{project}\n"
        "{footerline}\n"
        "{authors}"
    ).format(
        footerline=str('-' * 72),
        project=projectmacro,
        authors='\n'.join(author_strings)
        )


def main(arguements=None):
    """
    Program entry point.

    :param arguements:
    :return:
    """
    try:
        if arguements is None:  # __name__=__main__
            arguements = sys.argv[1:]
            progname = sys.argv[0]
        else:  # module entry
            arguements = arguements[1:]
            progname = arguements[0]
    except IndexError:
        print(return_epilog() + "\n")
        logging.error("Invalid options. Use --help for more information.")
        sys.exit(1)

    arg_parser = argparse.ArgumentParser(
        prog=progname,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=descriptionmacro,
        epilog=return_epilog())
    arg_parser.add_argument('COMMAND')
    arg_parser.add_argument(
        "-V",
        "--version",
        action='version',
        version='UNSUPPORTED OPTION'
        )
    arg_parser.add_argument(
        "--key",
        "-k",
        nargs='?',
        default=None,
        help="Optional with `check` command. Can be used to run checks on"
        " a limited subset of item headings under testSet from the yaml "
        "config."
        )
    arg_parser.add_argument(
        "--datatype",
        "-t",
        nargs='?',
        default=None,
        help="Required with `discover` command. This filters objects from"
        " the config that have a particular datatype. This data is used by"
        " low level discovery in Zabbix."
        )
    arg_parser.add_argument(
        "-c",
        "--config",
        default=None,
        help="Specify custom config file, system default /etc/url_monitor."
        "yaml"
        )
    arg_parser.add_argument(
        "--loglevel",
        default=None,
        help="Specify custom loglevel override. Available options [debug,"
        " info, wrna, critical, error, exceptions]"
    )

    inputflag = arg_parser.parse_args(args=arguements)

    configinstance = configuration.ConfigObject()
    configinstance.load_yaml_file(inputflag.config)
    logger = configinstance.get_logger(inputflag.loglevel)

    configinstance.pre_flight_check()
    config = configinstance.load()

    # establish single-run lockfile (pid)
    try:
        runlock = commons.AcquireRunLock(config['config']['pidfile'])
    except PidlockConflict, err:
        logging.error("Error: Could not acquire exclusive "
                      "lock {0}".format(err))
        print("1")
        exit(1)

    # skip if skip conditions exist (for standby nodes)
    conditional_skip_queue = configinstance.get_skip_conditions()
    if len(conditional_skip_queue) > 0:
        logger.info("Checking {0} standby conditions to see if test execution"
                    " should skip.".format(len(conditional_skip_queue)))
    for test in conditional_skip_queue:
        for condition, condition_args in test.items():
            commons.skip_on_external_condition(
                logger, condition, condition_args)

    if inputflag.COMMAND == "check":
        failed_exits = []
        for thisscheck in config['checks']:
            checkfailed = "0"
            try:
                if inputflag.key != None and thisscheck['key'] == inputflag.key:
                    # --key defined and name matched! only run 1 check
                    print(action.check(
                        thisscheck, configinstance, logger
                    ))
                    exit_val, checkobj = action.check(
                        thisscheck, configinstance, logger
                    )
                    if exit_val > 0:
                        checkfailed = "1"
                        failed_exits.append({thisscheck['key']: checkobj})
                elif not inputflag.key:
                    # run all checks
                    exit_val, checkobj = action.check(
                        thisscheck, configinstance, logger
                    )
                    if exit_val > 0:
                        checkfailed = "1"
                        failed_exits.append({thisscheck['key']: checkobj})
            except Exception as e:
                logger.exception(e)

            # Report failed conditions to zabbix
            logger.info(
                "Sending execution summary to zabbix server as Metrics objects")

            metrickey = config['config']['zabbix']['checksummary_key_format'].format(
                **checkobj)

            check_completion_status = [
                Metric(
                    config['config']['zabbix']['host'], metrickey, checkfailed
                )
            ]
            action.transmitfacade(
                configinstance=config,
                metrics=check_completion_status)

        # report error(s) to stdout
        if len(failed_exits) >= 1:
            logger.warn("{0} checks have failed".format(len(failed_exits)))
            set_rc = 2
        else:
            logger.warn("All checks completed".format(len(failed_exits)))
            set_rc = 0
    elif inputflag.COMMAND == "discover":
        action.discover(inputflag, configinstance, logger)
        set_rc = 0



def entry_point():
    """Zero-argument entry point for use with setuptools/distribute."""
    raise SystemExit(main(sys.argv))

    # drop lockfile
    if runlock.islocked():
        runlock.release()

if __name__ == "__main__":
    # do the UNIX double-fork magic, see Stevens' "Advanced
    # Programming in the UNIX Environment" for details (ISBN 0201563177)
    pid = os.fork()
    if pid > 0:
        # exit first parent
        sys.exit(0)

    # decouple from parent environment
    os.chdir("/")
    os.setsid()
    os.umask(0)

    # do second fork
    pid = os.fork()
    if pid > 0:
        # exit from second parent, print eventual PID before
        print("Daemon PID %d" % pid)
        sys.exit(0)

    # start the daemon main loop
    entry_point()
