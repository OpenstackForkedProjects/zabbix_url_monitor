#!/usr/bin/python
# -*- coding: utf-8 -*-
from __future__ import print_function

import argparse
import json
import logging
import os
import sys
import textwrap
import requests
from exception import PidlockConflict

import action
import commons
import configuration
from exception import PidlockConflict

import zbxsend as event
from zbxsend import Metric

from url_monitor import authors as authorsmacro
from url_monitor import description as descriptionmacro
from url_monitor import authors as emailsmacro
from url_monitor import project as projectmacro

__doc__ = """Program entry point / arg handling / check passfail review"""


def return_epilog():
    """ Formats the eplig footer generated by help """
    author_strings = []
    for name, email in zip(authorsmacro, emailsmacro):
        author_strings.append('Author: {0} <{1}>'.format(name, email))
    return (
        "{project}\n"
        "{footerline}\n"
        "{authors}"
    ).format(
        footerline=str('-' * 72),
        project=projectmacro,
        authors='\n'.join(author_strings)
    )


def main(arguements=None):
    """
    Program entry point.

    :param arguements:
    :return:
    """
    try:
        if arguements is None:  # __name__=__main__
            arguements = sys.argv[1:]
            progname = sys.argv[0]
        else:  # module entry
            arguements = arguements[1:]
            progname = arguements[0]
    except IndexError:
        print(return_epilog() + "\n")
        logging.error("Invalid options. Use --help for more information.")
        sys.exit(1)

    arg_parser = argparse.ArgumentParser(
        prog=progname,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=descriptionmacro,
        epilog=return_epilog())
    arg_parser.add_argument('COMMAND')
    arg_parser.add_argument(
        "-V",
        "--version",
        action='version',
        version='UNSUPPORTED OPTION'
    )
    arg_parser.add_argument(
        "--key",
        "-k",
        nargs='?',
        default=None,
        help="Optional with `check` command. Can be used to run checks on"
        " a limited subset of item headings under testSet from the yaml "
        "config."
    )
    arg_parser.add_argument(
        "--datatype",
        "-t",
        nargs='?',
        default=None,
        help="Required with `discover` command. This filters objects from"
        " the config that have a particular datatype. This data is used by"
        " low level discovery in Zabbix."
    )
    arg_parser.add_argument(
        "-c",
        "--config",
        default=None,
        help="Specify custom config file, system default /etc/url_monitor."
        "yaml"
    )
    arg_parser.add_argument(
        "--loglevel",
        default=None,
        help="Specify custom loglevel override. Available options [debug,"
        " info, wrna, critical, error, exceptions]"
    )

    inputflag = arg_parser.parse_args(args=arguements)

    configinstance = configuration.ConfigObject()
    configinstance.load_yaml_file(inputflag.config)
    logger = configinstance.get_logger(inputflag.loglevel)

    configinstance.pre_flight_check()
    config = configinstance.load()

    # establish single-run lockfile (pid)
    try:
        runlock = commons.AcquireRunLock(config['config']['pidfile'])
    except PidlockConflict, err:
        logging.error("Error: Could not acquire exclusive "
                      "lock {0}".format(err))
        print("1")
        exit(1)

    # skip if skip conditions exist (for standby nodes)
    conditional_skip_queue = configinstance.get_skip_conditions()
    if len(conditional_skip_queue) > 0:
        logger.info("Checking {0} standby conditions to see if test execution"
                    " should skip.".format(len(conditional_skip_queue)))
    for test in conditional_skip_queue:
        for condition, condition_args in test.items():
            commons.skip_on_external_condition(
                logger, condition, condition_args)

    if inputflag.COMMAND == "check":
        completed_runs = []
        for thisscheck in config['checks']:
            try:
                if (inputflag.key != None and
                        thisscheck['key'] == inputflag.key):
                    # --key defined and name matched! only run 1 check
                    rc, checkobj = action.check(
                        thisscheck, configinstance, logger
                    )
                    completed_runs.append(
                        (
                            rc,
                            thisscheck['key'],
                            checkobj
                        )
                    )
                elif not inputflag.key:
                    # run all checks
                    rc, checkobj = action.check(
                        thisscheck, configinstance, logger
                    )
                    completed_runs.append(
                        (
                            rc,
                            thisscheck['key'],
                            checkobj
                        )
                    )
            except Exception as e:
                logger.exception(e)

        for check in completed_runs:
            rc, name, values = check
            if rc == 0:
                set_rc = 0
            else:
                set_rc = 1

        badmsg = "with errors    [FAIL]"
        if set_rc == 0:
            badmsg = "without errors    [ OK ]"
        logger.info("Checks have completed {0}".format(badmsg))

        # Report final conditions to zabbix (so informational alerting can
        # be built around failed script runs, exceptions, network errors,
        # timeouts, etc)
        logger.info(
            "Sending execution summary to zabbix server as Metrics objects"
        )

        metrickey = config['config']['zabbix'][
            'checksummary_key_format'].format(**values)

        check_completion_status = [Metric(
            config['config']['zabbix']['host'], metrickey, set_rc
        )]
        action.transmitfacade(config, check_completion_status)

    elif inputflag.COMMAND == "discover":
        action.discover(inputflag, configinstance, logger)
        set_rc = 0

    # drop lockfile
    if runlock.islocked():
        runlock.release()
        print(set_rc)
        exit(set_rc)


def entry_point():
    """Zero-argument entry point for use with setuptools/distribute."""
    raise SystemExit(main(sys.argv))

if __name__ == "__main__":
    entry_point()
